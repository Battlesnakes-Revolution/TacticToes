
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =========== HELPER FUNCTIONS ===========
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isValidGameType(type) {
      return type in ['connect4', 'longboi', 'tactictoes', 'snek', 'colourclash', 'reversi', 'teamsnek', 'kingsnek'];
    }

    function isValidGamePlayers(players) {
      return players is list && players.size() > 0; // Assuming at least one player
    }

    function isValidTeam(team) {
      return team.keys().hasAll(['id', 'name', 'color']) &&
        team.id is string && team.id.size() > 0 &&
        team.name is string && team.name.size() > 0 && team.name.size() < 100 &&
        team.color is string && team.color.size() > 0;
    }

    // Validate teams array - manually check each possible index since Firestore rules don't support loops
    // This validates up to 10 teams (our max) by checking each index individually
    function isValidTeams(teams) {
      return teams is list && 
        teams.size() >= 2 && 
        teams.size() <= 10 &&
        // Validate each team based on array size
        (teams.size() < 1 || isValidTeam(teams[0])) &&
        (teams.size() < 2 || isValidTeam(teams[1])) &&
        (teams.size() < 3 || isValidTeam(teams[2])) &&
        (teams.size() < 4 || isValidTeam(teams[3])) &&
        (teams.size() < 5 || isValidTeam(teams[4])) &&
        (teams.size() < 6 || isValidTeam(teams[5])) &&
        (teams.size() < 7 || isValidTeam(teams[6])) &&
        (teams.size() < 8 || isValidTeam(teams[7])) &&
        (teams.size() < 9 || isValidTeam(teams[8])) &&
        (teams.size() < 10 || isValidTeam(teams[9]));
    }

    function isValidSetup(setup) {
      let hasRequiredFields = setup.keys().hasAll([
          'gameType', 'gamePlayers', 'boardWidth', 'boardHeight', 
          'playersReady', 'maxTurnTime', 'startRequested', 'started', 'timeCreated'
        ]);
      
      let validBaseFields = isValidGameType(setup.gameType) &&
        isValidGamePlayers(setup.gamePlayers) &&
        setup.boardWidth is int && setup.boardWidth >= 5 &&
        setup.boardHeight is int && setup.boardHeight >= 5 &&
        setup.playersReady is list &&
        setup.maxTurnTime is int && setup.maxTurnTime > 0 &&
        setup.startRequested is bool &&
        setup.started is bool &&
        (setup.timeCreated is timestamp || setup.timeCreated == request.time);
      
      // Additional validation for team-based games and optional fields
      let validOptionalFields = (!setup.keys().hasAny(['teams', 'maxTurns', 'gameMode', 'firstTurnTime'])) || (
        (!('teams' in setup.keys()) || isValidTeams(setup.teams)) &&
        (!('maxTurns' in setup.keys()) || (setup.maxTurns is int && setup.maxTurns > 0 && setup.maxTurns <= 1000)) &&
        (!('gameMode' in setup.keys()) || (setup.gameMode is string && setup.gameMode in ['individual', 'team'])) &&
        (!('firstTurnTime' in setup.keys()) || (setup.firstTurnTime is int && setup.firstTurnTime > 0))
      );
      
      return hasRequiredFields && validBaseFields && validOptionalFields;
    }

    function isValidPrivateMove(move) {
      return move.keys().hasAll(['gameID', 'moveNumber', 'playerID', 'move', 'timestamp']) &&
        move.gameID is string &&
        move.moveNumber is int && move.moveNumber >= 0 &&
        move.playerID is string &&
        move.move is int && move.move >= 0 &&
        (move.timestamp is timestamp || move.timestamp == request.time); // Allow server timestamp on create
    }

    function isValidMoveStatusUpdate(current, next) {
      let addedIds = next.movedPlayerIDs.removeAll(current.movedPlayerIDs);
      return current.moveNumber == next.moveNumber &&
        current.alivePlayerIDs == next.alivePlayerIDs &&
        addedIds.size() == 1 &&
        addedIds[0] == request.auth.uid;
    }

    function isValidBotData(botData, botId) {
      return botData.keys().hasAll(['id', 'owner', 'name', 'url', 'capabilities', 'emoji', 'colour', 'createdAt']) &&
        botData.id == botId &&
        botData.owner is string &&
        botData.name is string && botData.name.size() > 0 && botData.name.size() < 100 &&
        botData.url is string && botData.url.size() > 10 && botData.url.size() < 500 &&
        botData.capabilities is list && botData.capabilities.size() > 0 && botData.capabilities.size() < 10 &&
        botData.emoji is string && botData.emoji.size() > 0 && botData.emoji.size() < 10 &&
        botData.colour is string && botData.colour.matches('hsl\\([0-9]+(\\.[0-9]+)?,\\s*[0-9]+(\\.[0-9]+)?%,\\s*[0-9]+(\\.[0-9]+)?%\\)') &&
        (botData.createdAt == request.time);
    }

    // =========== USERS COLLECTION ===========
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if isUser(userId);
    }

    // =========== SESSIONS COLLECTION ===========
    match /sessions/{sessionId} {
      allow read: if true;
      allow create: if isAuthenticated();

      // Setups Subcollection
      match /setups/{setupId} {
        allow read: if true;
        allow create, update: if isAuthenticated() && isValidSetup(request.resource.data);
      }

      // Games Subcollection
      match /games/{gameId} {
        allow read: if true;

        // MoveStatuses Subcollection
        match /moveStatuses/{moveStatusId} {
          allow read: if true;
          allow update: if isAuthenticated() && isValidMoveStatusUpdate(resource.data, request.resource.data);
        }

        // PrivateMoves Subcollection
        match /privateMoves/{moveId} {
          allow create: if isAuthenticated() &&
            request.auth.uid == request.resource.data.playerID &&
            isValidPrivateMove(request.resource.data);
        }

        // ExpirationRequests Subcollection
        match /expirationRequests/{requestId} {
          allow read: if true;
          allow create: if isAuthenticated();
        }
      }
    }

    // =========== BOTS COLLECTION ===========
    match /bots/{botId} {
      allow read: if true;
      allow create: if isAuthenticated() &&
                       request.resource.data.owner == request.auth.uid &&
                       isValidBotData(request.resource.data, botId);
      allow delete: if isAuthenticated() && resource.data.owner == request.auth.uid;
    }

    // =========== RANKINGS COLLECTION ===========
    match /rankings/{playerID} {
      allow read: if true;
    }
  }
}
